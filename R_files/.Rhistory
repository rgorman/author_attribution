files.v <- dir(path=input.dir, pattern=".*xml")
i <- 1
book.freqs.l <- list ()
for (i in 1:length(files.v)) {
doc.object <- xmlTreeParse(file.path(input.dir, files.v[i]), useInternalNodes=TRUE)
sword.data <-getSwordTableList(doc.object)
book.freqs.l[[files.v[i]]] <-sword.data
}
summary(book.freqs.l)
freqs.l <- mapply(data.frame, ID=seq_along(book.freqs.l),
book.freqs.l, SIMPLIFY=FALSE, MoreArgs=list(stringsAsFactors=FALSE))
freqs.df <- do.call(rbind, freqs.l)
result <- xtabs(Freq ~ ID+sword.content.lower, data=freqs.df)
dim(result)
final.m <- apply(result, 2, as.numeric)
bookids.v <- gsub(".xml", "", files.v)
rownames(final.m) <-bookids.v
rownames(final.m)
smaller.m <- final.m[, apply(final.m,2,mean)>=.015]
dim(smaller.m)
sorted.m <- smaller.m[, order(colMeans(smaller.m), decreasing=TRUE) ]
View(sorted.m)
reduced.m <-sorted.m[, 1:5]
View(reduced.m)
delta.scores <-dist.delta(reduced.m)
View(delta.scores)
delta.scores
delta.scores <-as.matrix (dist.delta(reduced.m))
delta.scores
View(delta.scores)
reduced.m <-sorted.m[, 1:100]
delta.scores <-as.matrix (dist.delta(reduced.m))
View(delta.scores)
cosine.scores <- as.matrix(dist.cosine(reduced.m))
View(cosine.scores)
library(XML)
source("code/corpusFunctions.R")
input.dir <- "sWord_input/stat_files/rel_pos_files"
files.v <- dir(path=input.dir, pattern=".*xml")
book.freqs.l <- list()
for(i in 1:length(files.v)){
doc.object <- xmlTreeParse(file.path(input.dir, files.v[i]), useInternalNodes=TRUE)
chunk.data.l <- getSwordChunkMaster(doc.object, 2000)
book.freqs.l[[files.v[i]]] <-chunk.data.l
}
summary(book.freqs.l)
freqs.l <- list()
freqs.l <- lapply(book.freqs.l, my.apply)
freqs.df <- do.call(rbind, freqs.l)
dim(freqs.df)
bookids.v <- gsub(".xml.\\d+", "", rownames(freqs.df))
book.chunk.ids <- paste(bookids.v, freqs.df$ID, sep="_")
freqs.df$ID <- book.chunk.ids
result.t <- xtabs(Freq ~ ID+Var1, data=freqs.df)
dim(result.t)
short.chunks <- read.csv (file="Rresults/short_chunks2.csv")
View(short.chunks)
skip.v <-as.vector(short.chunks[,2])
reserve.t <- result.t
result.t <- result.t[-skip.v,]
dim(result.t)
dim(reserve.t)
final.df <- as.data.frame.matrix(result.t)
author.v <- gsub("_.+", "", rownames(final.df))
head(author.v)
unique(author.v)
length(author.v)
author.v
freq.means.v <- colMeans(final.df[, ])
keepers.v <- which(freq.means.v >=.00015)
smaller.df <- final.df[, keepers.v]
dim(smaller.df)
ordered.df <- smaller.df[, order(colMeans(smaller.df), decreasing=TRUE)]
View(ordered.df)
ordered.df.backup <- ordered.df
smaller.df.backup <- smaller.df
smaller.df <- ordered.df[, 1:180]
View(smaller.df)
short.prob.m <- read.csv (file="Rresults/short_parameters2.csv")
prob.m <- short.prob.m
library (gmodels)
library(klaR)
testing.index.v <- sample (seq (1, nrow(smaller.df)), 24, prob=prob.m$Prob)
testing.data <- smaller.df[testing.index.v, ]
training.data <- smaller.df[-testing.index.v, ]
training.classes <- as.factor(author.v[-testing.index.v])
testing.classes <- as.factor(author.v[testing.index.v])
View(smaller.df)
delta.results <- perform.delta(training.data, testing.data)
View(delta.results)
errormatrix(testing.classes, training.classes)
str(delta.results)
delta.result[[1]]
delta.results[[1]]
delta.results[[2]]
delta.results[[2]][1]
delta.results[[2]][3]
delta.results[[2]][2]
delta.results[[50]][2]
delta.results[[50]]
delta.results
cosine.results <- perform.delta(training.data, testing.data, distance=cosine)
cosine.results <- perform.delta(training.data, testing.data, distance="cosine")
cosine.results <- perform.delta(training.data, testing.data, distance="simple")
View(cosine.results)
dist.cosine(training.data)
cosine.scores <- as.matrix(dist.cosine(reduced.m))
cosine.scores <- as.matrix(dist.cosine(training.data))
View(training.data)
svm.results <- perform.delta(training.data, testing.data)
View(svm.results)
svm.results
attributes(svm.results)
names(attributes(svm.results))
svm.results$rankings
attr(svm.results. rankings)
attr(svm.results, rankings)
attr(svm.results, "rankings")
View(attr(svm.results, "rankings"))
names(attributes(svm.results))
View(attr(svm.results, "names"))
View(attr(svm.results, "distance.table"))
View(attr(svm.results, "scores"))
stylo()
training.classes <- author.v[-testing.index.v]
testing.classes <- author.v[testing.index.v]
errormatrix(training.classes, training.classes)
errormatrix(testing.classes, testing.classes)
attributes(svm.results)
attributes(svm.results) <-NULL
svm.results
errormatrix(testing.index, svm.results)
errormatrix(testing.classes, svm.results)
svm.results <- perform.delta(training.data, testing.data)
errormatrix(testing.classes, svm.results)
testing.classes <- as.factor(author.v[testing.index.v])
errormatrix(testing.classes, svm.results)
names(svm.results)
attributes(svm.results)
save(testing.classes.l, file="Rresults/svm_predictions/correctAnswers_Oct3.R")
svm.results.l <- list()
svm.error.matrix.l <- list()
testing.classes.l <- list()
i <- 1
for (i in 1:100) {
#create vector of random integers = 10% of obs in smaller.df
testing.index.v <- sample (seq (1, nrow(smaller.df)), 24, prob=prob.m$Prob)
#create training and testing data matrices using testing.index.v and its inverse
testing.data <- smaller.df[testing.index.v, ]
training.data <- smaller.df[-testing.index.v, ]
#create vectors of factors giving classes (here = authors) of each row in testing.data and training.data
training.classes <- as.factor(author.v[-testing.index.v])
testing.classes <- as.factor(author.v[testing.index.v])
# carry out prediction test using svm
svm.results.l[[i]] <- perform.svm(training.data, test.data)
svm.error.matrix.l[[i]] <- errormatrix(testing.classes, svm.results.l[[i]])
#make record of testing_classes
testing.classes.l[[i]] <-testing.classes
}
svm.results.l <- list()
svm.error.matrix.l <- list()
testing.classes.l <- list()
i <- 1
for (i in 1:100) {
#create vector of random integers = 10% of obs in smaller.df
testing.index.v <- sample (seq (1, nrow(smaller.df)), 24, prob=prob.m$Prob)
#create training and testing data matrices using testing.index.v and its inverse
testing.data <- smaller.df[testing.index.v, ]
training.data <- smaller.df[-testing.index.v, ]
#create vectors of factors giving classes (here = authors) of each row in testing.data and training.data
training.classes <- as.factor(author.v[-testing.index.v])
testing.classes <- as.factor(author.v[testing.index.v])
# carry out prediction test using svm
svm.results.l[[i]] <- perform.svm(training.data, testing.data)
svm.error.matrix.l[[i]] <- errormatrix(testing.classes, svm.results.l[[i]])
#make record of testing_classes
testing.classes.l[[i]] <-testing.classes
}
svm.results.l[[1]]
svm.error.matrix.l[[1]]
svm.error.matrix.l[[10]]
svm.results.l <- list()
svm.error.matrix.l <- list()
testing.classes.l <- list()
i <- 1
for (i in 1:1000) {
#create vector of random integers = 10% of obs in smaller.df
testing.index.v <- sample (seq (1, nrow(smaller.df)), 24, prob=prob.m$Prob)
#create training and testing data matrices using testing.index.v and its inverse
testing.data <- smaller.df[testing.index.v, ]
training.data <- smaller.df[-testing.index.v, ]
#create vectors of factors giving classes (here = authors) of each row in testing.data and training.data
training.classes <- as.factor(author.v[-testing.index.v])
testing.classes <- as.factor(author.v[testing.index.v])
# carry out prediction test using svm
svm.results.l[[i]] <- perform.svm(training.data, testing.data)
svm.error.matrix.l[[i]] <- errormatrix(testing.classes, svm.results.l[[i]])
#make record of testing_classes
testing.classes.l[[i]] <-testing.classes
}
svm.error.matrix.l[[999]]
save(svm.results.l, file="Rresults/svm_predictions/svmResults_Oct3.R")
a <- do.call(rbind, svm.error.matrix.l)
save(svm.error.matrix.l, file="Rresults/svm_predictions/svmErrorMatrix_Oct3.R")
my.list <- mapply(data.frame, testing.classes.l)
d <- do.call (rbind, my.list)
write.csv (d, file="Rresults/svm_predictions/right_answers_Oct3.csv")
save(testing.classes.l, file="Rresults/svm_predictions/correctAnswers_Oct3.R")
View(ordered.df)
feature.number.v <- seq(2, 500, 2)
svm.error.matrix.l[[1]]
svm.error.matrix.l[[1]][12,12]
sapply(svm.error.matrix.l[12,12])
f1 <- function(x, append(error.v, svm.error.matrix.l[12,12]))
length(svm.error.matrix.l)
error.v <- NULL
sapply(svm.error.matrix.l, (svm.error.matrix.l[12,12]+0))
sapply(svm.error.matrix.l, (svm.error.matrix.l+0))
for (i in 1:length(svm.error.matrix.l)) {
append(error.v, svm.error.matrix.l[[i]][12,12])
}
i <- 1
for (i in 1:length(svm.error.matrix.l)) {
append(error.v, svm.error.matrix.l[[i]][12,12])
}
svm.error.matrix.l[[1]][12,12]
svm.error.matrix.l[[2]][12,12]
str(svm.error.matrix.l)
svm.error.matrix.l[[999]]
attributes(svm.error.matrix.l
)
attributes(svm.error.matrix.l)
svm.error.matrix.l[[999]]
svm.error.matrix.l[[999]][12,]
svm.error.matrix.l[[999]]
str(svm.error.matrix.l[[999]])
attr(svm.error.matrix.l[[999]])
attr(svm.error.matrix.l[[999]][1])
attr(svm.error.matrix.l[[999]], "true")
attr(svm.error.matrix.l[[999]]$true)
names(attr(svm.error.matrix.l[[999]]))
names(attr(svm.error.matrix.l))
names(attributes(svm.error.matrix.l))
names(attributes(svm.error.matrix.l[[1]]))
names(attributes(svm.error.matrix.l[[2]]))
attr(svm.error.matrix.l[[1]], "dim")
attr(svm.error.matrix.l[[1]], "dimnames")
stripped.matrix.l < list()
stripped.matrix.l < list()
list()
stipped.l <- list()
stipped.l <- svm.error.matrix.l
attributes(stripped.l) <- NULL
attributes(stipped.l) <- NULL
stipped.l[[99]]
stipped.l[[99]][1,1]
length(stipped.l)
i <- 1
for (i in 1:length(stipped.l)) {
append(error.v, stipped.l[[i]][12,12])
}
stipped.l[[999]]
stipped.l[[999]][11,11]
i <- 1
for (i in 1:length(stipped.l)) {
append(error.v, stipped.l[[i]][11,11])
}
append(error.v, stipped.l[[1]][11,11])
append(error.v, stipped.l[[2]][11,11])
error.v
i <- 1
error.v <- append(error.v, stipped.l[[2]][11,11])
error.v <- append(error.v, stipped.l[[3]][11,11])
error.v <- append(error.v, stipped.l[[2]][11,11])
error.v <- NULL
i <- 1
for (i in 1:length(stipped.l)) {
error.v <- append(error.v, stipped.l[[i]][11,11])
}
error.v <- append(error.v, stipped.l[[14]][11,11])
svm.error.matrix.l[[14]][12,12]
svm.error.matrix.l[[14]][11,11]
svm.error.matrix.l[[14]]
length(stipped.l[[14]])
length(stipped.l[[13]])
length(stipped.l[[14]])
sqrt(length(stipped.l[[14]]))
sqrt(length(stipped.l[[12]]))
error.v <- NULL
i <- 1
for (i in 1:1000) {
error.v <- append(error.v, stipped.l[[i]][sqrt(length(stipped.l[[i]])), sqrt(length(stipped.l[[i]]))])
}
sum(error.v)
sum(error.v)/24000
1-sum(error.v)/24000
i <- 1
for (i in 1:1000) {
error.v <- append(error.v, svm.error.matrix.l[[i]][sqrt(length(svm.error.matrix.l[[i]])), sqrt(length(svm.error.matrix.l[[i]]))])
}
error.v <- NULL
i <- 1
for (i in 1:1000) {
error.v <- append(error.v, svm.error.matrix.l[[i]][sqrt(length(svm.error.matrix.l[[i]])), sqrt(length(svm.error.matrix.l[[i]]))])
}
error.matrix.l[[999]]
svm.error.matrix.l[[999]]
svm.error.matrix.l[[999]][2,2]
svm.results.l <-list()
svm.error.matrix.l <- list()
testing.classes.l <- list()
total.errors.l <- list()
total.errors2.l <- list()
i <- 1
j <- 1
for (j in 1:2) {
error.v <- NULL
feature.df <- ordered.df[, 1:feature.number.v[j]]
for (i in 1:100) {
#create vector of random integers = 10% of obs in smaller.df
testing.index.v <- sample (seq (1, nrow(feature.df)), 24, prob=prob.m$Prob)
#create training and testing data matrices using testing.index.v and its inverse
testing.data <- feature.df[testing.index.v, ]
training.data <- feature.df[-testing.index.v, ]
#create vectors of factors giving classes (here = authors) of each row in testing.data and            # training.data
training.classes <- as.factor(author.v[-testing.index.v])
testing.classes <- as.factor(author.v[testing.index.v])
# carry out prediction test using svm
svm.results.l[[i]] <- perform.svm(training.data, testing.data)
# create errror matrix of results and put into object
svm.error.matrix.l[[i]] <- errormatrix(testing.classes, svm.results.l[[i]])
#make record of testing_classes
testing.classes.l[[i]] <-testing.classes
# save sum of errors in each iteration from error matrix to error.v
error.v  <- <- append(error.v, svm.error.matrix.l[[i]][sqrt(length(svm.error.matrix.l[[i]])), sqrt(length(svm.error.matrix.l[[i]]))])
}
# save grand total of errors for each iteration into list object along with number of features
total.errors.l[[j]] <- error.v
i <- 1
}
error.v <- NULL
feature.df <- ordered.df[, 1:feature.number.v[j]]
for (i in 1:100) {
#create vector of random integers = 10% of obs in smaller.df
testing.index.v <- sample (seq (1, nrow(feature.df)), 24, prob=prob.m$Prob)
#create training and testing data matrices using testing.index.v and its inverse
testing.data <- feature.df[testing.index.v, ]
training.data <- feature.df[-testing.index.v, ]
#create vectors of factors giving classes (here = authors) of each row in testing.data and            # training.data
training.classes <- as.factor(author.v[-testing.index.v])
testing.classes <- as.factor(author.v[testing.index.v])
# carry out prediction test using svm
svm.results.l[[i]] <- perform.svm(training.data, testing.data)
# create errror matrix of results and put into object
svm.error.matrix.l[[i]] <- errormatrix(testing.classes, svm.results.l[[i]])
#make record of testing_classes
testing.classes.l[[i]] <-testing.classes
# save sum of errors in each iteration from error matrix to error.v
error.v  <- <- append(error.v, svm.error.matrix.l[[i]][sqrt(length(svm.error.matrix.l[[i]])), sqrt(length(svm.error.matrix.l[[i]]))])
}
for (i in 1:100) {
#create vector of random integers = 10% of obs in smaller.df
testing.index.v <- sample (seq (1, nrow(feature.df)), 24, prob=prob.m$Prob)
#create training and testing data matrices using testing.index.v and its inverse
testing.data <- feature.df[testing.index.v, ]
training.data <- feature.df[-testing.index.v, ]
#create vectors of factors giving classes (here = authors) of each row in testing.data and            # training.data
training.classes <- as.factor(author.v[-testing.index.v])
testing.classes <- as.factor(author.v[testing.index.v])
# carry out prediction test using svm
svm.results.l[[i]] <- perform.svm(training.data, testing.data)
# create errror matrix of results and put into object
svm.error.matrix.l[[i]] <- errormatrix(testing.classes, svm.results.l[[i]])
#make record of testing_classes
testing.classes.l[[i]] <-testing.classes
# save sum of errors in each iteration from error matrix to error.v
error.v  <- <- append(error.v, svm.error.matrix.l[[i]][sqrt(length(svm.error.matrix.l[[i]])), sqrt(length(svm.error.matrix.l[[i]]))])
}
for (i in 1:100) {
1+1
}
i <- 1
for (i in 1:100) {
1+1
}
(1+1)
i <- 1
for (i in 1:100) {
(1+1)
}
i <- 1
for (i in 1:100) {
#create vector of random integers = 10% of obs in smaller.df
testing.index.v <- sample (seq (1, nrow(feature.df)), 24, prob=prob.m$Prob)
#create training and testing data matrices using testing.index.v and its inverse
testing.data <- feature.df[testing.index.v, ]
training.data <- feature.df[-testing.index.v, ]
#create vectors of factors giving classes (here = authors) of each row in testing.data and            # training.data
training.classes <- as.factor(author.v[-testing.index.v])
testing.classes <- as.factor(author.v[testing.index.v])
# carry out prediction test using svm
svm.results.l[[i]] <- perform.svm(training.data, testing.data)
# create errror matrix of results and put into object
svm.error.matrix.l[[i]] <- errormatrix(testing.classes, svm.results.l[[i]])
#make record of testing_classes
testing.classes.l[[i]] <-testing.classes
# save sum of errors in each iteration from error matrix to error.v
error.v  <- <- append(error.v, svm.error.matrix.l[[i]][sqrt(length(svm.error.matrix.l[[i]])), sqrt(length(svm.error.matrix.l[[i]]))])
}
for (i in 1:100) {
#create vector of random integers = 10% of obs in smaller.df
testing.index.v <- sample (seq (1, nrow(feature.df)), 24, prob=prob.m$Prob)
#create training and testing data matrices using testing.index.v and its inverse
testing.data <- feature.df[testing.index.v, ]
training.data <- feature.df[-testing.index.v, ]
#create vectors of factors giving classes (here = authors) of each row in testing.data and            # training.data
training.classes <- as.factor(author.v[-testing.index.v])
testing.classes <- as.factor(author.v[testing.index.v])
# carry out prediction test using svm
svm.results.l[[i]] <- perform.svm(training.data, testing.data)
# create errror matrix of results and put into object
svm.error.matrix.l[[i]] <- errormatrix(testing.classes, svm.results.l[[i]])
#make record of testing_classes
testing.classes.l[[i]] <-testing.classes
# save sum of errors in each iteration from error matrix to error.v
error.v  <-  append(error.v, svm.error.matrix.l[[i]][sqrt(length(svm.error.matrix.l[[i]])), sqrt(length(svm.error.matrix.l[[i]]))])
}
error.v
svm.results.l <-list()
svm.error.matrix.l <- list()
testing.classes.l <- list()
total.errors.l <- list()
total.errors2.l <- list()
i <- 1
j <- 1
for (j in 1:2) {
error.v <- NULL
feature.df <- ordered.df[, 1:feature.number.v[j]]
for (i in 1:100) {
#create vector of random integers = 10% of obs in smaller.df
testing.index.v <- sample (seq (1, nrow(feature.df)), 24, prob=prob.m$Prob)
#create training and testing data matrices using testing.index.v and its inverse
testing.data <- feature.df[testing.index.v, ]
training.data <- feature.df[-testing.index.v, ]
#create vectors of factors giving classes (here = authors) of each row in testing.data and            # training.data
training.classes <- as.factor(author.v[-testing.index.v])
testing.classes <- as.factor(author.v[testing.index.v])
# carry out prediction test using svm
svm.results.l[[i]] <- perform.svm(training.data, testing.data)
# create errror matrix of results and put into object
svm.error.matrix.l[[i]] <- errormatrix(testing.classes, svm.results.l[[i]])
#make record of testing_classes
testing.classes.l[[i]] <-testing.classes
# save sum of errors in each iteration from error matrix to error.v
error.v  <- append(error.v, svm.error.matrix.l[[i]][sqrt(length(svm.error.matrix.l[[i]])), sqrt(length(svm.error.matrix.l[[i]]))])
}
# save grand total of errors for each iteration into list object along with number of features
total.errors.l[[j]] <- error.v
i <- 1
}
total.errors.l[[1]]
total.errors.l[[2]]
svm.results.l <-list()
svm.error.matrix.l <- list()
testing.classes.l <- list()
total.errors.l <- list()
total.errors2.l <- list()
i <- 1
j <- 1
for (j in 1:250) {
error.v <- NULL
feature.df <- ordered.df[, 1:feature.number.v[j]]
for (i in 1:100) {
#create vector of random integers = 10% of obs in smaller.df
testing.index.v <- sample (seq (1, nrow(feature.df)), 24, prob=prob.m$Prob)
#create training and testing data matrices using testing.index.v and its inverse
testing.data <- feature.df[testing.index.v, ]
training.data <- feature.df[-testing.index.v, ]
#create vectors of factors giving classes (here = authors) of each row in testing.data and            # training.data
training.classes <- as.factor(author.v[-testing.index.v])
testing.classes <- as.factor(author.v[testing.index.v])
# carry out prediction test using svm
svm.results.l[[i]] <- perform.svm(training.data, testing.data)
# create errror matrix of results and put into object
svm.error.matrix.l[[i]] <- errormatrix(testing.classes, svm.results.l[[i]])
#make record of testing_classes
testing.classes.l[[i]] <-testing.classes
# save sum of errors in each iteration from error matrix to error.v
error.v  <- append(error.v, svm.error.matrix.l[[i]][sqrt(length(svm.error.matrix.l[[i]])), sqrt(length(svm.error.matrix.l[[i]]))])
}
# save grand total of errors for each iteration into list object along with number of features
total.errors.l[[j]] <- error.v
i <- 1
}
save (total.errors.l, file="Rresults/svmIterationTest_Oct5.R")
total.errors.l[[2]]
total.errors.l[[120]]
x <- seq(2, 500, 2)
iteration.m <- matrix (x, nrow=250, ncol=1)
iteration.m <- (cbind(iteration.m, lapply(total.errors.l, sum)))
iteration.m <- (cbind(iteration.m, unlist(lapply(total.errors.l, sum))/2400 ))
iteration.m <- (cbind(iteration.m, 1-(unlist(lapply(total.errors.l, sum))/2400) ))
View(iteration.m)
plot(iteration.m$V4, iteration.m$V4 )
plot(iteration.m$V4, iteration.m$V1 )
plot(iteration.m)
plot(iteration.m[,4], iteration.m[,1])
plot(iteration.m[,1], iteration.m[,4])
write.csv(iteration.m, file="Rresults/svmRel_pos_iterationTest_Oct5.csv")
cvm.results <-  read.csv(file="Rresults/svmRel_pos_iterationTest_Oct5.csv")
names(cvm.results)
plot(cvm.results$No_of_Vars, cvm.results$RunningAverage)
